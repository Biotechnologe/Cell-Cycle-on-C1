```{r echo=FALSE}
options(width=120)
knitr::opts_knit$set(verbose = TRUE)
```

DDBJ data management
====================

The following description is only suitable for the download and renaming of fastq file stored at [DDBJ](http://trace.ddbj.nig.ac.jp/DRASearch/submission?acc=DRA002399). However, the same data can be obtained from [NCBI](http://www.ncbi.nlm.nih.gov/Traces/sra/?study=DRP002435) and [EBI](https://www.ebi.ac.uk/ena/data/view/DRP002435) 

First create a directory in which to download all the 945 compressed fastq files.

```{r download, engine='sh', eval=FALSE}
# create a directory for data download, go to that directory and start the download of all fastq files from the 
mkdir 'yourdirectoryname'; cd 'yourdirectoryname'
lftp ftp://ftp.ddbj.nig.ac.jp/ddbj_database/dra/fastq/DRA002/DRA002399
mget -c */*.bz2
```

The following script creates a table that has 6 columns: "Library",  "Well", "DDBJ", "Index", "ExperimentAccession", "cell_id", and 472 rows. Each row represents a single cell. 

- **"Library"**: the sequencing flowcell run ID (e.g. "RNhi10371")
- **"Well"**: the coordinate of a cell on the 96-well plate after transfer of cDNA from the C1 capture array 
- **"DDBJ"**: the unique cell ID given to each cell by DDBJ
- **"Index"**: the left and right read (2 x 8 bases) barcode used to pool 96 cells per run
- **"ExperimentAccession"**: the name given by DDBJ that is the equivalent of the "Library" run ID 
- **"Run"**: the C1 capture array ID 
- **"cell_id"**: a unique identifier for each single cell, that is created by combining the C1 IFC ID and the "Well" with an underscore delimeter

```{r load_libraries}
library(XML)
library(reshape)
```

The XML metadata is downloaded from DDBJ, and parsed in R.  Informations such
as run ID, DDBJ accession numbers and Barcodes are extracted with XPath
queries.

```{r get_and_parse_XML}
DDBJ <- xmlTreeParse("ftp://ftp.ddbj.nig.ac.jp/ddbj_database/dra/fastq/DRA002/DRA002399/DRA002399.experiment.xml", useInternal=T)
top        <- xmlRoot(DDBJ)
RunID      <- xpathApply(top, "//LIBRARY_NAME", xmlValue)
Experiment <- xpathApply(top, "//EXPERIMENT", xmlAttrs)
Accession  <- lapply(Experiment, function(x) x[1])
Barcodes   <- xpathApply(top, "//LIBRARY_CONSTRUCTION_PROTOCOL", xmlValue)
Barcodes   <- gsub("\n", "", as.character(Barcodes))
Barcodes   <- strsplit(Barcodes, split=', ')
names(Barcodes) <- paste(RunID, Accession, sep="_")
```

A correspondance table between barcodes and well IDs (from the 96-well plates)
was prepared by hand according to the Fluidigm protocol 'PN 100-5950 A1' and
saved in text format.  It is loaded in R with the following command.

```{r load_well_ID}
WellID <- read.csv("WellToBarcodes.csv", header=T, stringsAsFactors=F)
```

Each Fluidigm run produced one multiplexed library that was sequenced on one
lane, so there is a one-to-one correspondence between run IDs and sequence
library IDs, as described in the vector below.  See the [HiSeq QC page](../HiSeq/HiSeq.Rmd)
for more information.

```{r library_ID}
LibraryToC1ID <- c( RNhi10371="1772-062-248"
                  , RNhi10372="1772-062-249"
                  , RNhi10395="1772-064-103"
                  , RNhi10396="1772-067-038"
                  , RNhi10397="1772-067-039")
```

The metadata is then aggreated with the well IDs in a single table.

```{r link_table}
# create combined table in long format with run ID and DDBJ ID and barcode
link <- melt(Barcodes)
names(link) <- c("DDBJIndex", "Library")

# separate DDBJ name and Index
intermediate <- read.table(text=as.character(link$DDBJIndex), sep=':')

# split RunID and ExperimentAccession in column 1 of final
intermediate2 <- read.table(text=as.character(link$Library), sep='_')

# Paste the intermediate tables as a new 'link' table.
link <- cbind(intermediate, intermediate2)
names(link) <- c("DDBJ", "Index", "Library", "ExperimentAccession")

# associate each Index from the DDBJ XML with the Well coordinates
link$Well <- WellID$Well[match(as.character(link$Index), as.character(WellID$Index))]

# get cell IDs for DDBJ names
link$Run <- as.character(sapply(link$Library, function(x) LibraryToC1ID[x]))
link$cell_id <- paste(link$Run, link$Well, sep="_")
head(link)
```

```{r, eval=T}
# write final output table to current working directory
write.csv(link, "DDBJLink.csv", row.names=F)
```

The next part utilises the file "DDBJLink.csv" to rename downloaded fastq.bz2 files with the unique "cell_id".
Adjust the below script to the directory in which the "DDBJLink.csv" is located. Furthermore, your working directory should be 'yourdirectoryname' where all the dowloaded fastq.bz2 files are saved. 

```{r renaming the fastq.bz2 files with cell_id, engine='sh', eval=F}
# the code below replaces the "DDBJ" name of each fastq.bz2 file pair with the corresponding "cell_id"
cut -f4,8 DDBJLink.csv | sed 1d | while read from to ; do mv ${from}_1.fastq.bz2 ${to}.1.fastq.bz2 ; mv ${from}_2.fastq.bz2 ${to}.2.fastq.bz2; done
```

The file fastq_md5sum.csv contains the md5 checksums for all fastq.bz2 files after renaming and can be used for validity checks by comparing the md5sums of your local renamed files.

```{r md5sum check, engine='sh', eval=F}
# execute in the directory with the renamed files
ls -lh | awk '{print $9}' | xargs md5sum >> ../fastq_md5sums.txt
```
